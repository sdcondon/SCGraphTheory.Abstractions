# Graph Theory Abstractions

[![NuGet version (SCGraphTheory.Abstractions)](https://img.shields.io/nuget/v/SCGraphTheory.Abstractions.svg?style=flat-square)](https://www.nuget.org/packages/SCGraphTheory.Abstractions/)

[Graph theory](https://en.wikipedia.org/wiki/Graph_theory) interfaces - [IGraph<TNode,TEdge,TEdges>](/src/Abstractions/IGraph{TNode,TEdge,TEdges}.cs), [INode<TNode,TEdge,TEdges>](/src/Abstractions/INode{TNode,TEdge,TEdges}.cs) and [IEdge<TNode,TEdge,TEdges>](/src/Abstractions/IEdge{TNode,TEdge,TEdges}.cs) - to allow for graph algorithms that do not depend on a particular graph representation.

Example implementation and usage can be found in the separate [SCGraphTheory.AdjacencyList](https://github.com/sdcondon/SCGraphTheory.AdjacencyList) and [SCGraphTheory.Search](https://github.com/sdcondon/SCGraphTheory.Search) repositories, respectively. Additional (test-focused) implementation examples can be found in the [TestGraphs library](https://github.com/sdcondon/SCGraphTheory.Search/blob/master/src/Search.TestGraphs) in SCGraphTheory.Search. Notably:
- A super-simple (though rather inefficient) [LINQ-powered immutable implementation](https://github.com/sdcondon/SCGraphTheory.Search/blob/master/src/Search.TestGraphs/LinqGraph.cs). Used for tests in the search algorithm package.
- A [square grid implementation using structs](https://github.com/sdcondon/SCGraphTheory.Search/blob/master/src/Search.TestGraphs/ValGridGraph{T}.cs). Involves no up-front heap allocations other than a 2D array of node values, but performs relatively poorly under search because lots of data gets moved around compared to a class-based implementation (including a little boxing - see notes, below). Included in search benchmarks project because I was interested in the performance impact.
- A bare-bones [adjacency matrix implementation](https://github.com/sdcondon/SCGraphTheory.Search/blob/master/src/Search.TestGraphs/AdjacencyMatrixGraph.cs). Doesn't actually feature in any tests - I was just curious to know what an adjacency matrix implementation of these interfaces could look like.

Notes:
* The fact that the IEdge abstraction has a "From" and a "To" doesn't make this abstraction unsuitable for undirected graphs. Graph algorithms will generally traverse edges in a particular direction, making this a useful interface, and while the AdjacencyList implementation doesn't do this (thus favouring low latency over low memory usage), there's nothing stopping an implementation (with reference type edges) from making the IEdge implementation a value type created from the ref type edge, depending on the current node - thus avoiding "duplicated" undirected edges on the heap.  
  
  ..The elephant in the room of course is the Edges property of IGraph, which, given that it returns IEdges, necessarily should include both directions of an undirected edge - which could cause confusion. If there's ever a breaking change made to this library for a v2, this is where it's likely to be (probably by simply removing it).. In the meantime I'm not sure there are actually many algorithms that enumerate all graph edges, so its perhaps not a big deal..?
* Why `INode` and not `IVertex`? The reasoning was that 'node' is synonymous and shorter - but I'll confess I regret this choice sometimes.